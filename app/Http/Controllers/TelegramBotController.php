<?php

namespace App\Http\Controllers;

use Illuminate\Http\Request;
use Illuminate\Support\Facades\Log;
use Illuminate\Support\Facades\Storage;
use GuzzleHttp\Client;
use GuzzleHttp\Exception\RequestException;
use Illuminate\Http\JsonResponse;

class TelegramBotController extends Controller
{
    private string $token;
    private Client $client;
    private string $plannerServiceUrl = 'https://1e046903-d28b-444d-bdff-685a9c37343a.tunnel4.com/api';
    private array $activePolls = [];

    public function __construct()
    {
        $this->token = env('TELEGRAM_BOT_TOKEN');
        $this->validateToken();
        $this->client = new Client([
            'timeout' => 100,
            'connect_timeout' => 10,
        ]);
    }

    public function handleWebhook(Request $request): JsonResponse
    {
        $input = $request->all();
        Log::info('–í—Ö–æ–¥—è—â–∏–π –≤–µ–±—Ö—É–∫ Telegram:', $input);

        if (!isset($input['message'])) {
            return response()->json(['status' => 'error', 'message' => '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π –∑–∞–ø—Ä–æ—Å']);
        }

        $message = $input['message'];
        $chatId = $message['chat']['id'];
        $userId = $message['from']['id'];
        $text = $message['text'] ?? '';
        $messageTime = $message['date'] ?? time();

        if (strtolower($text) === '/cancel') {
            $response = $this->handleCancelCommand($userId, $chatId);
        } else {
            $response = $this->handleUserInput($userId, $chatId, $text, $messageTime);
        }

        $this->sendMessage($chatId, $response);
        return response()->json(['status' => 'success']);
    }

    private function handleUserInput(int $userId, int $chatId, string $text, int $messageTime): string
    {
        $state = $this->getUserState($userId);

        if (!empty($state)) {
            if (isset($state['timestamp']) && $messageTime < $state['timestamp']) {
                return "‚åõ –°–æ–æ–±—â–µ–Ω–∏–µ —É—Å—Ç–∞—Ä–µ–ª–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –≤–≤–æ–¥.";
            }

            if (isset($state['pending_action']) && $state['pending_action'] === 'generate_plan') {
                return $this->handlePlanGenerationDataCollection($userId, $chatId, $text, $state);
            }
        }

        switch ($text) {
            case '/start':
            case '/help':
                return $this->getHelpMessage();
            
            case '/plan':
                $userData = $this->getUserData($userId);
                $goal = $userData['goal'] ?? null;
                return $goal 
                    ? "üìã –¶–µ–ª—å: {$goal}" 
                    : "‚ùå –¶–µ–ª—å –Ω–µ –∑–∞–¥–∞–Ω–∞. –í–≤–µ–¥–∏—Ç–µ /EnterGoal –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è —Ü–µ–ª–∏.";
            
            case '/EnterGroup':
                $this->setUserState($userId, [
                    'step' => 'waiting_for_group',
                    'timestamp' => time()
                ]);
                return "üìö –í–≤–µ–¥–∏—Ç–µ –Ω–æ–º–µ—Ä –≤–∞—à–µ–π –≥—Ä—É–ø–ø—ã (–Ω–∞–ø—Ä–∏–º–µ—Ä, –ü–ò–ù-36):";
            
            case '/EnterGoal':
                if (!$this->getUserData($userId)['group']) {
                    return "‚ö†Ô∏è –°–Ω–∞—á–∞–ª–∞ —É–∫–∞–∂–∏—Ç–µ –≥—Ä—É–ø–ø—É —á–µ—Ä–µ–∑ /EnterGroup";
                }
                $this->setUserState($userId, [
                    'step' => 'waiting_for_goal',
                    'timestamp' => time()
                ]);
                return "üéØ –í–≤–µ–¥–∏—Ç–µ –≤–∞—à—É —É—á–µ–±–Ω—É—é —Ü–µ–ª—å:";
            
            case '/GeneratePlan':
                return $this->initiatePlanGenerationFlow($userId, $chatId);
            
            case '/Cancel':
                return $this->handleCancelCommand($userId, $chatId);
            
            default:
                return $this->handleUserState($userId, $text, $state);
        }
    }

    private function getHelpMessage(): string
    {
        return "ü§ñ –î–æ—Å—Ç—É–ø–Ω—ã–µ –∫–æ–º–∞–Ω–¥—ã:\n"
            . "/start - –ù–∞—á–∞—Ç—å —Ä–∞–±–æ—Ç—É\n"
            . "/help - –°–ø—Ä–∞–≤–∫–∞\n"
            . "/plan - –ü–æ–∫–∞–∑–∞—Ç—å —Ç–µ–∫—É—â—É—é —Ü–µ–ª—å\n"
            . "/EnterGroup - –£–∫–∞–∑–∞—Ç—å –≥—Ä—É–ø–ø—É\n"
            . "/EnterGoal - –£–∫–∞–∑–∞—Ç—å —Ü–µ–ª—å\n"
            . "/GeneratePlan - –°–æ–∑–¥–∞—Ç—å –ø–ª–∞–Ω\n"
            . "/Cancel - –û—Ç–º–µ–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é";
    }

    /**
     * @param array{step?: string, timestamp?: int, pending_action?: string, missing_data?: string[], current_step?: int} $state
     */
    private function handleUserState(int $userId, string $text, ?array $state): string
    {
        if (empty($state)) {
            return "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞";
        }

        switch ($state['step']) {
            case 'waiting_for_group':
                $this->saveUserData($userId, ['group' => $text]);
                $this->clearUserState($userId);
                return "‚úÖ –ì—Ä—É–ø–ø–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞! –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ /EnterGoal –¥–ª—è —É–∫–∞–∑–∞–Ω–∏—è —Ü–µ–ª–∏";
            
            case 'waiting_for_goal':
                $this->saveUserData($userId, ['goal' => $text]);
                $this->clearUserState($userId);
                $group = $this->getUserData($userId)['group'];
                return "‚úÖ –¶–µ–ª—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞!\n–ì—Ä—É–ø–ø–∞: {$group}\n–¶–µ–ª—å: {$text}";
            
            default:
                return "‚ùå –ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –∫–æ–º–∞–Ω–¥–∞";
        }
    }

    private function initiatePlanGenerationFlow(int $userId, int $chatId): string
    {
        if (isset($this->activePolls[$userId])) {
            return "‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–∞ —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è. –î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /Cancel.";
        }

        $userData = $this->getUserData($userId);
        $missing = $this->getMissingData($userData);

        if (!empty($missing)) {
            return $this->initiateDataCollection($userId, $missing);
        }

        return $this->executePlanGeneration($userId, $chatId, $userData);
    }

    /**
     * @param array{group?: string, goal?: string} $userData
     * @return string[]
     */
    private function getMissingData(array $userData): array
    {
        $missing = [];
        if (empty($userData['group'])) $missing[] = 'group';
        if (empty($userData['goal'])) $missing[] = 'goal';
        return $missing;
    }

    /**
     * @param string[] $missing
     */
    private function initiateDataCollection(int $userId, array $missing): string
    {
        $this->setUserState($userId, [
            'pending_action' => 'generate_plan',
            'missing_data' => $missing,
            'current_step' => 0,
            'timestamp' => time()
        ]);
        
        return $this->generateDataRequestMessage($missing[0]);
    }

    private function generateDataRequestMessage(string $field): string
    {
        $messages = [
            'group' => "üìù –î–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞ —É–∫–∞–∂–∏—Ç–µ –≤–∞—à—É –≥—Ä—É–ø–ø—É:",
            'goal' => "üéØ –¢–µ–ø–µ—Ä—å –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à—É —É—á–µ–±–Ω—É—é —Ü–µ–ª—å:"
        ];
        return $messages[$field] ?? "‚ÑπÔ∏è –í–≤–µ–¥–∏—Ç–µ —Ç—Ä–µ–±—É–µ–º—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é:";
    }

    /**
     * @param array{pending_action: string, missing_data: string[], current_step: int, timestamp: int} $state
     */
    private function handlePlanGenerationDataCollection(int $userId, int $chatId, string $text, array $state): string
    {
        $missing = $state['missing_data'];
        $currentStep = $state['current_step'];
        $currentField = $missing[$currentStep];

        $this->saveUserData($userId, [$currentField => $text]);
        $nextStep = $currentStep + 1;

        if ($nextStep >= count($missing)) {
            $this->clearUserState($userId);
            return $this->executePlanGeneration($userId, $chatId, $this->getUserData($userId));
        }

        $this->setUserState($userId, [
            'pending_action' => 'generate_plan',
            'missing_data' => $missing,
            'current_step' => $nextStep,
            'timestamp' => time()
        ]);

        return $this->generateDataRequestMessage($missing[$nextStep]);
    }

    /**
     * @param array{group: string, goal: string} $userData
     */
    private function executePlanGeneration(int $userId, int $chatId, array $userData): string
    {
        $existingJobId = $this->getJobData($userId);
        if ($existingJobId) {
            Log::info("–ü–æ–ø—ã—Ç–∫–∞ –ø–æ–≤—Ç–æ—Ä–Ω–æ–≥–æ –∑–∞–ø—É—Å–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞ –¥–ª—è user {$userId}, job {$existingJobId}. –û—Ç–∫–ª–æ–Ω–µ–Ω–æ.");
            return "‚è≥ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–∞ —É–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ—Ç—Å—è (Job ID: {$existingJobId}). –î–æ–∂–¥–∏—Ç–µ—Å—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏—è –∏–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ /Cancel.";
        }

        try {
            Log::debug('–û—Ç–ø—Ä–∞–≤–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞:', [
                'user_id' => $userId,
                'goal' => $userData['goal'],
                'group_id' => $userData['group']
            ]);

            $response = $this->client->post("{$this->plannerServiceUrl}/generate-plan", [
                'headers' => [
                    'Content-Type' => 'application/json',
                    'Accept' => 'application/json'
                ],
                'json' => [
                    'user_id' => $userId,
                    'goal' => $userData['goal'],
                    'group_id' => $userData['group']
                ]
            ]);

            if ($response->getStatusCode() === 202) {
                $responseData = json_decode($response->getBody(), true);
                $jobId = $responseData['job_id'] ?? null;

                if (!$jobId) {
                    Log::error("–ù–µ –ø–æ–ª—É—á–µ–Ω job_id –æ—Ç –≤–Ω–µ—à–Ω–µ–≥–æ —Å–µ—Ä–≤–∏—Å–∞ –¥–ª—è user {$userId}");
                    return "‚ùå –û—à–∏–±–∫–∞: –Ω–µ –ø–æ–ª—É—á–µ–Ω –∏–¥–µ–Ω—Ç–∏—Ñ–∏–∫–∞—Ç–æ—Ä –∑–∞–¥–∞—á–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.";
                }

                $this->saveJobData($userId, $jobId);
                $this->startPolling($userId, $chatId, $jobId, $userData['goal'], $userData['group']);
                
                return "üöÄ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–∞ –Ω–∞—á–∞—Ç–∞!\n"
                     . "‚ñ∏ –ì—Ä—É–ø–ø–∞: {$userData['group']}\n"
                     . "‚ñ∏ –¶–µ–ª—å: {$userData['goal']}\n"
                     . "–Ø –ø—Ä–∏—à–ª—é –ø–ª–∞–Ω, –∫–∞–∫ —Ç–æ–ª—å–∫–æ –æ–Ω –±—É–¥–µ—Ç –≥–æ—Ç–æ–≤!";
            }
        } catch (RequestException $e) {
            Log::error("–û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ –ø–ª–∞–Ω–∞ –¥–ª—è user {$userId}: " . $e->getMessage());
            Log::debug('–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:', ['trace' => $e->getTraceAsString()]);
            $this->clearJobData($userId);
            return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –ø–ª–∞–Ω–∞: " . $e->getMessage() . ". –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.";
        }

        $this->clearJobData($userId);
        return "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–ø—É—Å—Ç–∏—Ç—å –≥–µ–Ω–µ—Ä–∞—Ü–∏—é –ø–ª–∞–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.";
    }

    private function startPolling(int $userId, int $chatId, string $jobId, string $goal, string $group): void
    {
        if (isset($this->activePolls[$userId])) {
            Log::warning("–û–ø—Ä–æ—Å —É–∂–µ –∞–∫—Ç–∏–≤–µ–Ω –¥–ª—è user {$userId}. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –Ω–æ–≤—ã–π –æ–ø—Ä–æ—Å.");
            return;
        }

        $this->activePolls[$userId] = [
            'cancelled' => false,
            'start_time' => time(),
            'job_id' => $jobId
        ];
        Log::info("–ù–∞—á–∞—Ç –æ–ø—Ä–æ—Å –¥–ª—è user {$userId}, job {$jobId}");
        $this->pollPlanResult($userId, $chatId, $jobId, $goal, $group);
    }

    private function pollPlanResult(int $userId, int $chatId, string $jobId, string $goal, string $group): void
    {
        $maxTime = 100;
        $interval = 15;
        $startTime = $this->activePolls[$userId]['start_time'] ?? time();

        if ((time() - $startTime) >= $maxTime) {
            Log::warning("–ü—Ä–µ–≤—ã—à–µ–Ω–æ –≤—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è (100 —Å–µ–∫) –¥–ª—è user {$userId}, job {$jobId}.");
            $this->sendMessage($chatId, "‚åõ –í—Ä–µ–º—è –æ–∂–∏–¥–∞–Ω–∏—è –æ—Ç–≤–µ—Ç–∞ –∏—Å—Ç–µ–∫–ª–æ. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞ —Å –ø–æ–º–æ—â—å—é /GeneratePlan.");
            unset($this->activePolls[$userId]);
            $this->clearJobData($userId);
            return;
        }

        if (!isset($this->activePolls[$userId]) || $this->activePolls[$userId]['cancelled']) {
            Log::info("–û–ø—Ä–æ—Å –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –¥–ª—è user {$userId}: –æ—Ç–º–µ–Ω–µ–Ω –∏–ª–∏ –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω–æ–≥–æ –æ–ø—Ä–æ—Å–∞.");
            unset($this->activePolls[$userId]);
            $this->clearJobData($userId);
            return;
        }

        try {
            Log::debug("–û–ø—Ä–æ—Å —Å—Ç–∞—Ç—É—Å–∞ –¥–ª—è user {$userId}, job {$jobId}");
            $response = $this->client->get("{$this->plannerServiceUrl}/get-plan-result/{$jobId}", [
                'headers' => ['Accept' => 'application/json'],
                'timeout' => 30,
            ]);

            $responseData = json_decode($response->getBody(), true);
            $status = $responseData['status'] ?? 'unknown';

            Log::debug("–°—Ç–∞—Ç—É—Å –æ–ø—Ä–æ—Å–∞ –¥–ª—è user {$userId}, job {$jobId}: {$status}");

            if ($status === 'completed') {
                $this->sendFormattedPlan($chatId, $responseData['plan_data']);
                Log::info("–ü–ª–∞–Ω —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω –¥–ª—è user {$userId}, job {$jobId}.");
                unset($this->activePolls[$userId]);
                $this->clearJobData($userId);
                return;
            } elseif ($status === 'failed') {
                $errorMsg = $responseData['error_details'] ?? '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞';
                $this->sendMessage($chatId, "‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏: {$errorMsg}. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
                Log::info("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–∞ –Ω–µ —É–¥–∞–ª–∞—Å—å –¥–ª—è user {$userId}, job {$jobId}.");
                unset($this->activePolls[$userId]);
                $this->clearJobData($userId);
                return;
            }

            sleep($interval);
            $this->pollPlanResult($userId, $chatId, $jobId, $goal, $group);
        } catch (RequestException $e) {
            Log::error("–û—à–∏–±–∫–∞ –æ–ø—Ä–æ—Å–∞ –¥–ª—è user {$userId}, job {$jobId}: " . $e->getMessage());
            Log::debug('–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:', ['trace' => $e->getTraceAsString()]);
            $this->sendMessage($chatId, "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ —Å—Ç–∞—Ç—É—Å–∞: " . $e->getMessage() . ". –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.");
            unset($this->activePolls[$userId]);
            $this->clearJobData($userId);
        }
    }

    /**
     * @param array{plan_title: string, estimated_duration_weeks: string, weekly_overview: array<array{week_number: int, weekly_goal: string, daily_tasks: array<array{day_name: string, learning_activities: array<array{topic: string, description: string, suggested_slot: string, estimated_duration_minutes: int, resources?: string[]}>}>, general_recommendations?: string} $planData
     */
    private function sendFormattedPlan(int $chatId, array $planData): void
    {
        $formatted = "üìò *{$planData['plan_title']}*\n";
        $formatted .= "‚è≥ –ü—Ä–æ–¥–æ–ª–∂–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å: {$planData['estimated_duration_weeks']}\n\n";

        foreach ($planData['weekly_overview'] as $week) {
            $formatted .= "üìå *–ù–µ–¥–µ–ª—è {$week['week_number']}: {$week['weekly_goal']}*\n";
            
            foreach ($week['daily_tasks'] as $day) {
                $formatted .= "\n*{$day['day_name']}*\n";
                
                foreach ($day['learning_activities'] as $activity) {
                    $formatted .= "‚è∞ {$activity['suggested_slot']} ({$activity['estimated_duration_minutes']} –º–∏–Ω)\n";
                    $formatted .= "üîπ *{$activity['topic']}*\n{$activity['description']}\n";
                    
                    if (!empty($activity['resources']) && is_array($activity['resources'])) {
                        $formatted .= "üìö –†–µ—Å—É—Ä—Å—ã: " . implode(', ', $activity['resources']) . "\n";
                    }
                    $formatted .= "\n";
                }
            }
            $formatted .= "\n";
        }

        if (!empty($planData['general_recommendations'])) {
            $formatted .= "\nüí° *–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:*\n{$planData['general_recommendations']}";
        }

        $this->sendMessage($chatId, $formatted);
    }

    private function handleCancelCommand(int $userId, int $chatId): string
    {
        if (!isset($this->activePolls[$userId])) {
            return "‚ÑπÔ∏è –ù–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –æ–ø–µ—Ä–∞—Ü–∏–π –¥–ª—è –æ—Ç–º–µ–Ω—ã";
        }

        $jobId = $this->activePolls[$userId]['job_id'] ?? null;
        $this->activePolls[$userId]['cancelled'] = true;
        unset($this->activePolls[$userId]);
        $this->clearJobData($userId);

        if ($jobId) {
            try {
                $this->client->post("{$this->plannerServiceUrl}/cancel-plan/{$jobId}", [
                    'headers' => ['Accept' => 'application/json'],
                    'timeout' => 10,
                ]);
                Log::info("–ó–∞–ø—Ä–æ—Å –Ω–∞ –æ—Ç–º–µ–Ω—É –∑–∞–¥–∞–Ω–∏—è {$jobId} –¥–ª—è user {$userId} —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω.");
            } catch (RequestException $e) {
                Log::error("–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–ø—Ä–∞–≤–∫–µ –∑–∞–ø—Ä–æ—Å–∞ –Ω–∞ –æ—Ç–º–µ–Ω—É –∑–∞–¥–∞–Ω–∏—è {$jobId} –¥–ª—è user {$userId}: " . $e->getMessage());
                Log::debug('–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:', ['trace' => $e->getTraceAsString()]);
            }
        }

        try {
            $this->sendMessage($chatId, "‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞");
            Log::info("–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–∞ —É—Å–ø–µ—à–Ω–æ –æ—Ç–º–µ–Ω–µ–Ω–∞ –¥–ª—è user {$userId}, job {$jobId}.");
            return "‚úÖ –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–ª–∞–Ω–∞ –æ—Ç–º–µ–Ω–µ–Ω–∞";
        } catch (\Exception $e) {
            Log::error("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –æ–± –æ—Ç–º–µ–Ω–µ –¥–ª—è user {$userId}: " . $e->getMessage());
            Log::debug('–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:', ['trace' => $e->getTraceAsString()]);
            return "‚ö†Ô∏è –û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–º–µ–Ω–µ: " . $e->getMessage() . ". –û–ø–µ—Ä–∞—Ü–∏—è –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞, –ø–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.";
        }
    }

    private function validateToken(): void
    {
        if (empty($this->token) || !preg_match('/^\d+:[\w-]+$/', $this->token)) {
            Log::error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π —Ç–æ–∫–µ–Ω Telegram');
            abort(500, '–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω–∞—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –±–æ—Ç–∞');
        }
    }

    private function sendMessage(int $chatId, string $text): void
    {
        try {
            $this->client->post("https://api.telegram.org/bot{$this->token}/sendMessage", [
                'form_params' => [
                    'chat_id' => $chatId,
                    'text' => $text,
                    'parse_mode' => 'Markdown'
                ],
                'timeout' => 10,
            ]);
            Log::debug("–°–æ–æ–±—â–µ–Ω–∏–µ —É—Å–ø–µ—à–Ω–æ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ –≤ —á–∞—Ç {$chatId}: {$text}");
        } catch (\Exception $e) {
            Log::error("–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ —á–∞—Ç {$chatId}: " . $e->getMessage());
            Log::debug('–î–µ—Ç–∞–ª–∏ –æ—à–∏–±–∫–∏:', ['trace' => $e->getTraceAsString()]);
            throw $e;
        }
    }

    /**
     * @param array{step?: string, timestamp?: int, pending_action?: string, missing_data?: string[], current_step?: int} $state
     */
    private function setUserState(int $userId, array $state): void
    {
        $states = Storage::exists('user_states.json') 
            ? json_decode(Storage::get('user_states.json'), true)
            : [];
        
        $states[$userId] = $state;
        $json = json_encode($states, JSON_PRETTY_PRINT);
        if ($json === false) {
            Log::error("–û—à–∏–±–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON –¥–ª—è user_states: " . json_last_error_msg());
            return;
        }
        Storage::put('user_states.json', $json);
    }

    /**
     * @return array{step?: string, timestamp?: int, pending_action?: string, missing_data?: string[], current_step?: int}
     */
    private function getUserState(int $userId): array
    {
        if (!Storage::exists('user_states.json')) return [];
        $states = json_decode(Storage::get('user_states.json'), true);
        return $states[$userId] ?? [];
    }

    private function clearUserState(int $userId): void
    {
        $states = Storage::exists('user_states.json') 
            ? json_decode(Storage::get('user_states.json'), true)
            : [];
        
        unset($states[$userId]);
        $json = json_encode($states, JSON_PRETTY_PRINT);
        if ($json === false) {
            Log::error("–û—à–∏–±–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON –¥–ª—è user_states: " . json_last_error_msg());
            return;
        }
        Storage::put('user_states.json', $json);
    }

    /**
     * @param array{group?: string, goal?: string} $data
     */
    private function saveUserData(int $userId, array $data): void
    {
        $existing = Storage::exists('user_data.json') 
            ? json_decode(Storage::get('user_data.json'), true)
            : [];
        
        $existing[$userId] = array_merge($existing[$userId] ?? [], $data);
        $json = json_encode($existing, JSON_PRETTY_PRINT);
        if ($json === false) {
            Log::error("–û—à–∏–±–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON –¥–ª—è user_data: " . json_last_error_msg());
            return;
        }
        Storage::put('user_data.json', $json);
    }

    /**
     * @return array{group?: string, goal?: string}
     */
    private function getUserData(int $userId): array
    {
        if (!Storage::exists('user_data.json')) return [];
        $data = json_decode(Storage::get('user_data.json'), true);
        return $data[$userId] ?? [];
    }

    private function saveJobData(int $userId, string $jobId): void
    {
        $jobs = Storage::exists('user_jobs.json') 
            ? json_decode(Storage::get('user_jobs.json'), true)
            : [];
        
        $jobs[$userId] = $jobId;
        $json = json_encode($jobs, JSON_PRETTY_PRINT);
        if ($json === false) {
            Log::error("–û—à–∏–±–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON –¥–ª—è user_jobs: " . json_last_error_msg());
            return;
        }
        Storage::put('user_jobs.json', $json);
    }

    private function clearJobData(int $userId): void
    {
        $jobs = Storage::exists('user_jobs.json') 
            ? json_decode(Storage::get('user_jobs.json'), true)
            : [];
        
        unset($jobs[$userId]);
        $json = json_encode($jobs, JSON_PRETTY_PRINT);
        if ($json === false) {
            Log::error("–û—à–∏–±–∫–∞ –∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è JSON –¥–ª—è user_jobs: " . json_last_error_msg());
            return;
        }
        Storage::put('user_jobs.json', $json);
    }

    private function getJobData(int $userId): ?string
    {
        if (!Storage::exists('user_jobs.json')) {
            return null;
        }
        $jobs = json_decode(Storage::get('user_jobs.json'), true);
        return $jobs[$userId] ?? null;
    }

    public function getUserDataEndpoint(): JsonResponse
    {
        return response()->json(
            Storage::exists('user_data.json') 
                ? json_decode(Storage::get('user_data.json'), true)
                : []
        );
    }
}